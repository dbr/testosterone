import os
import sys
import unittest
from StringIO import StringIO

from testosterone.cli.utils import *


def detail(name_dotted):
    """Given a dotted module name, return a detail report on its tests.
    """

    # Get a TestSuite.
    # ================

    module = load(name_dotted)
    suite = flatten(unittest.defaultTestLoader.loadTestsFromModule(module))


    # Run tests.
    # ==========
    # We only write our report to stdout after the tests have been run. This is
    # necessary because we don't want to clutter the report with an program
    # output and/or pdb sessions.

    report = StringIO()
    print >> report, BANNER
    runner = unittest.TextTestRunner(report)
    runner.run(suite)
    return report.getvalue()


class _Summarize:
    """Given a dotted module name, return a summary report on its tests.

    The format of the report is:

        -------------<| testosterone |>-------------
        <header row>
        --------------------------------------------
        <name> <passing> <failures> <errors> <total>
        --------------------------------------------
        TOTALS <passing> <failures> <errors> <total>

    Boilerplate rows are actually 80 characters long, though. <passing> is given
    as a percentage (with a terminating percent sign); the other three are given
    in absolute terms. Data rows will be longer than 80 characters iff the field
    values exceed the following character lengths:

        name        60
        failures     4
        errors       4
        total        4

    If quiet is True (the default), then modules with no tests are not listed in
    the output; if False, they are. If recursive is False, then only the module
    explicitly named will be touched. If it is True (the default), then all
    submodules will also be included in the output, unless their name contains a
    stopword. If run is False, then no statistics on passes, failures, and
    errors will be available, and the output for each will be a dash character
    ('-'). run defaults to True.

    The report is delivered after it is fully complete. We do this rather than
    delivering data in real time in order to avoid program output and pdb
    sessions from cluttering up our report.

    This callable is implemented as a class to make testing easier. It should be
    used via the singleton named summarize.

    """

    def __init__(self):

        self.report = StringIO()
        self.runner = unittest.TextTestRunner(dev_null())
        self.load = unittest.defaultTestLoader.loadTestsFromModule


    def __call__(self, base, quiet=True, recursive=True, run=True, stopwords=()):

        self.base = base
        self.quiet = quiet
        self.recursive = recursive
        self.run = run
        self.stopwords = stopwords

        self.modules = self.get_modules()

        self.print_header()
        self.print_body()
        self.print_footer()

        return self.report.getvalue()


    def get_modules(self):
        """Given a dotted module name and a boolean, return a list of modules.
        """

        module = load(self.base)
        modules = [module]

        if self.recursive:
            path = os.path.dirname(module.__file__)
            for name in sorted(sys.modules):
                if name == modules[0].__name__:
                    continue
                try:
                    for word in self.stopwords:
                        if word and word in name:
                            stop = True
                            raise StopWord
                except StopWord:
                    continue
                if not name.startswith(self.base):
                    continue
                module = sys.modules[name]
                if module is None:
                    continue
                if not module.__file__.startswith(path):
                    # Skip external modules that ended up in our namespace.
                    continue
                modules.append(module)

        return modules


    def print_header(self):
        """Print the report header.
        """
        print >> self.report, BANNER
        print >> self.report, HEADERS
        print >> self.report, BORDER


    def print_body(self):
        """Print the report body; set three members on self for print_footer.
        """

        tfail = terr = tall = 0

        for module in self.modules:

            pass5 = fail = err = 0 # FWIW: pass -> pass% -> pass5
            suite = flatten(self.load(module))
            all = suite.countTestCases()


            # Run tests if requested.
            # =======================
            # If we aren't running the tests, include all modules in the report.
            # If we are, then only report on modules with failures/errors.

            if self.run:
                pass5 = fail = err = 0
                if all != 0:
                    result = self.runner.run(suite)
                    fail = len(result.failures)
                    err = len(result.errors)
                    pass5 = (all - fail - err) / float(all)
                    pass5 =  int(round(pass5*100))
                yes = (not self.quiet) or fail or err

                tall += all
                tfail += fail
                terr += err

            else:
                pass5 = fail = err = '-'
                yes = True
                tall += all


            # If applicable, format and print.
            # ================================

            if yes:
                name = module.__name__.ljust(60)
                sfail, serr, sall = [str(s).rjust(4) for s in (fail, err, all)]
                if pass5 == '-':
                    pass5 = '  - '
                else: # int
                    pass5 = str(pass5).rjust(3)+'%'
                print >> self.report, name, pass5, sfail, serr, sall


        self.tfail, self.terr, self.tall = tfail, terr, tall


    def print_footer(self, *totals):
        """Print the report footer; uses the 3 integers set by print_body.
        """

        tfail, terr, tall = self.tfail, self.terr, self.tall

        if self.run:
            tpass5 = 0
            if tall:
                tpass5 = (tall - tfail - terr) / float(tall)
            tpass5 = int(round(tpass5*100))
            tpass5 = str(tpass5).rjust(3)+'%'
        else:
            tfail = '-'
            terr = '-'
            tpass5 = '- '

        raw = (tpass5, tfail, terr, tall)
        tpass5, tfail, terr, tall = [str(s).rjust(4) for s in raw]

        print >> self.report, BORDER
        print >> self.report, "TOTALS".ljust(60), tpass5, tfail, terr, tall


summarize = _Summarize()
