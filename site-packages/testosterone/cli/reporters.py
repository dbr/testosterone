import os
import sys
import unittest
from StringIO import StringIO

from testosterone.cli.utils import *


def detail(name_dotted):
    """Given a dotted module name, return a detail report on its tests.
    """

    # Get a TestSuite.
    # ================

    module = load(name_dotted)
    suite = flatten(unittest.defaultTestLoader.loadTestsFromModule(module))


    # Run tests.
    # ==========
    # We only write our report to stdout after the tests have been run. This is
    # necessary because we don't want to clutter the report with an program
    # output and/or pdb sessions.

    report = StringIO()
    print >> report, BANNER
    runner = unittest.TextTestRunner(report)
    runner.run(suite)
    return report.getvalue()


class _Summarize:
    """Given a dotted module name, return a summary report on its tests.

    The format of the report is:

        -------------<| testosterone |>-------------
        <header row>
        --------------------------------------------
        <name> <passing> <failures> <errors> <total>
        --------------------------------------------
        TOTALS <passing> <failures> <errors> <total>

    Boilerplate rows are actually 80 characters long, though. <passing> is given
    as a percentage (with a terminating percent sign); the other three are given
    in absolute terms. Data rows will be longer than 80 characters iff the field
    values exceed the following character lengths:

        name        60
        failures     4
        errors       4
        total        4

    If quiet is True (the default), then modules with no tests are not listed in
    the output; if False, they are. If recursive is False, then only the module
    explicitly named will be touched. If it is True (the default), then all
    submodules will also be included in the output, unless their name contains a
    stopword. If run is False, then no statistics on passes, failures, and
    errors will be available, and the output for each will be a dash character
    ('-'). run defaults to True.

    The report is delivered after it is fully complete. We do this rather than
    delivering data in real time in order to avoid program output and pdb
    sessions from cluttering up our report.

    This callable is implemented as a class to make testing easier. It should be
    used via the singleton named summarize.

    """

    def __call__(self, base, quiet=True, recursive=True, run=True, stopwords=()):

        modules = self.get_modules(base, recursive, stopwords)
        self.runner = unittest.TextTestRunner(dev_null()) # swallow unittest output

        self.report = StringIO()

        self.print_header()
        totals = self.print_body(modules, quiet, run)
        self.print_footer(*totals)

        return self.report.getvalue()


    def get_modules(self, base, recursive, stopwords):
        """Given a dotted module name and a boolean, return a list of modules.
        """

        module = load(base)
        modules = [module]

        if recursive:
            path = os.path.dirname(module.__file__)
            for name in sorted(sys.modules):
                if name == modules[0].__name__:
                    continue
                stop = False
                for word in stopwords:
                    if word and word in name:
                        stop = True
                if stop:
                    continue
                if not name.startswith(base):
                    continue
                module = sys.modules[name]
                if module is None:
                    continue
                if not module.__file__.startswith(path):
                    # Skip external modules that ended up in our namespace.
                    continue
                modules.append(module)

        return modules


    def print_header(self):
        """Print the report header.
        """
        print >> self.report, BANNER
        print >> self.report, HEADERS
        print >> self.report, BORDER


    def print_body(self, modules, quiet, run):
        """Print the report body; return a 4-tuple of totals.
        """

        tpass5 = tfail = terr = tall = '-'
        tall = 0
        if run:
            tfail = terr = tall = 0
        for module in modules:
            suite = flatten(unittest.defaultTestLoader.loadTestsFromModule(module))
            pass5 = fail = err = '-'
            all = suite.countTestCases()
            tall += all
            if not run:
                yes = True
            else:
                if all != 0:
                    result = self.runner.run(suite)
                    fail = len(result.failures)
                    err = len(result.errors)
                    pass5 = (all - fail - err) / float(all)
                    pass5 =  int(round(pass5*100))
                    tfail += fail
                    terr += err

                has_result = (fail not in ('-', 0)) or (err not in ('-', 0))
                yes = (not quiet) or has_result

            name = module.__name__.ljust(60)
            if pass5 == '-':
                pass5 = '  - '
            else:
                pass5 = str(pass5).rjust(3)+'%'

            fail = str(fail).rjust(4)
            err = str(err).rjust(4)
            all = str(all).rjust(4)

            if yes:
                print >> self.report, name, pass5, fail, err, all

        return (tpass5, tfail, terr, tall)


    def print_footer(self, *totals):
        """Given the tuple from _print_body, print the report footer.
        """

        tpass5, tfail, terr, tall = totals

        if tall:
            if '-' not in (tfail, terr):
                tpass5 = (tall - tfail - terr) / float(tall)
                tpass5 =  int(round(tpass5*100))
        else:
            tfail = '-'
            terr = '-'
        if tpass5 == '-':
            tpass5 = '  - '
        else:
            tpass5 = str(tpass5).rjust(3)+'%'
        tfail = str(tfail).rjust(4)
        terr = str(terr).rjust(4)
        tall = str(tall).rjust(4)
        print >> self.report, BORDER
        print >> self.report, "TOTAL".ljust(60), tpass5, tfail, terr, tall


summarize = _Summarize()
