import logging
import os
import subprocess
import sys

from testosterone.cli.utils import BANNER, BORDER, HEADERS
from testosterone.interactive.utils import RefreshError


BREAK1 = ("=" * 70) + '\n'
BREAK2 = ("-" * 70) + '\n'

logger = logging.getLogger('testosterone.tests')


class Detail:
    """Represent the data from an inter-process detail() call.

    This is designed to be a persistent object. Repeated calls to refresh will
    update the dataset. Unlike Summary, there are no partial updates here. The
    assumption is that you will always want to re-run all tests at once. There
    is a show flag for each record; only items for which this are true are
    included in the name, index and __len__ calls.

    """

    base = ''       # the current base dotted module name
    data = None     # a dictionary, {name:<6-list>}:
                    #   0-3 summarize() data: pass5, fail, err, all
                    #   4   bool; whether to show this item
                    #   5   None/False/True; whether the data is recent
    names = None    # a sorted list of names for which show is True
    result = ''     # the text at the end of a detail report


    def __init__(self, base):
        """
        """
        self.base = base
        self.data = {}
        self.names = []


    # Container emulation
    # ===================

    def __getitem__(self, i):
        """Takes an int index into self.names
        """
        name = self.names[i]
        return [name] + self.data[name]

    def __len__(self):
        """Only count items for which show is True.
        """
        return len(self.names)

    def __iter__(self):
        return self.names.__iter__()
    iterkeys = __iter__


    # Main callable
    # =============

    def refresh(self):
        """Re-run our tests.
        """
        self._call()
        self._set_data()


    # Helpers
    # =======

    def _call(self):
        """Invoke a child process and return its output.

        We hand on our environment and any sys.path manipulations to the child,
        and we capture stderr as well as stdout so we can handle errors.

        """
        args = ( sys.executable
               , sys.argv[0]
               , '--scripted'
               , '--detail'
               , self.base
                )
        environ = os.environ.copy()
        environ['PYTHONPATH'] = ':'.join(sys.path)
        proc = subprocess.Popen( args=args
                               , stdout=subprocess.PIPE
                               , stderr=subprocess.STDOUT
                               , env=environ
                                )
        raw = proc.stdout.read()
        if BANNER not in raw:
            raise RefreshError(raw)
        self.__raw = raw


    def _set_data(self):
        """Extract and store data from __raw.
        """

        garbage, report = self.__raw.split(BANNER)
        items, result = report.rsplit(BREAK2,1)
        details = items.split(BREAK1)[1:]

        data = {}
        for detail in details:
            logger.debug(detail)
            flub, name, foo = detail.split(None, 2)
            if flub == 'FAIL:':
                flub = 'failure'
            elif flub == 'ERROR:':
                flub = 'error'
            data[name] = (flub, detail)

        del self.__raw

        self.result = result
        self.data = data
        self.names = sorted(data)
