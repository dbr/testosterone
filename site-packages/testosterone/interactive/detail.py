import logging
import os
import re
import subprocess
import sys

from testosterone.cli.utils import BANNER, BORDER, HEADERS
from testosterone.interactive.utils import RefreshError


BREAK1 = ("=" * 70) + '\n'
BREAK2 = ("-" * 70) + '\n'

ALL_RE = re.compile('Ran (\d*) tests')
FAIL_RE = re.compile('failures=(\d*)')
ERR_RE = re.compile('errors=(\d*)')

logger = logging.getLogger('testosterone.tests')


class Detail:
    """Represent the data from an inter-process detail() call.

    This is designed to be a persistent object. Repeated calls to refresh will
    update the dataset. Unlike Summary, there are no partial updates here. The
    assumption is that you will always want to re-run all tests at once. There
    is a show flag for each record; only items for which this are true are
    included in the name, index and __len__ calls.

    """

    base = ''       # the current base dotted module name
    data = None     # a dictionary, {name:<2-list>}:
                    #   0 'error' or 'failure'
                    #   1 full report
    names = None    # a sorted list of names for which show is True
    totals = ()     # a 4-tuple: (pass5, fail, err, all)


    def __init__(self, base):
        """
        """
        self.base = base
        self.data = {}
        self.names = []

    def __repr__(self):
        return "<Detail (%d tests)>" % len(self.names)



    # Container emulation
    # ===================

    def __getitem__(self, i):
        """Takes an int index into self.names
        """
        name = self.names[i]
        return [name] + self.data[name]

    def __len__(self):
        return len(self.names)

    def __iter__(self):
        return self.names.__iter__()


    # Main callable
    # =============

    def refresh(self):
        """Re-run our tests.
        """
        self._call()
        self._set_data()


    # Helpers
    # =======

    def _call(self):
        """Invoke a child process and return its output.

        We hand on our environment and any sys.path manipulations to the child,
        and we capture stderr as well as stdout so we can handle errors.

        """
        args = ( sys.executable
               , sys.argv[0]
               , '--scripted'
               , '--detail'
               , self.base
                )
        environ = os.environ.copy()
        environ['PYTHONPATH'] = ':'.join(sys.path)
        proc = subprocess.Popen( args=args
                               , stdout=subprocess.PIPE
                               , stderr=subprocess.STDOUT
                               , env=environ
                                )
        raw = proc.stdout.read()
        if BANNER not in raw:
            raise RefreshError(raw)
        self.__raw = raw


    def _set_data(self):
        """Extract and store data from __raw.
        """

        garbage, report = self.__raw.split(BANNER)
        items, result = report.rsplit(BREAK2,1)
        details = items.split(BREAK1)[1:]

        m = ALL_RE.search(result)
        all = m.group(1)
        fail = err = '0'
        if 'FAILED' in result:
            m = FAIL_RE.search(result)
            if m is not None:
                fail = str(m.group(1))
            m = ERR_RE.search(result)
            if m is not None:
                err = str(m.group(1))
        pass5 = str(int(100 * (int(all) - int(fail) - int(err)) / float(all)))
        totals = (pass5, fail, err, all)

        data = {}
        for detail in details:
            flub, name, traceback_plus = detail.split(None, 2)
            if flub == 'FAIL:':
                flub = 'failure'
            elif flub == 'ERROR:':
                flub = 'error'
            traceback_ = traceback_plus.split(BREAK2)[1]
            data[name] = [flub, traceback_]

        del self.__raw

        self.totals = totals
        self.data = data
        self.names = sorted(data, cmp=self._cmp)


    def _cmp(self, a, b):
        """Sort on error/failure, then on test name.
        """
        flub_a = self.data[a][0]
        flub_b = self.data[b][0]
        if flub_a == flub_b:
            return cmp(a, b)
        elif flub_a > flub_b:
            return 1
        elif flub_a < flub_b:
            return -1

