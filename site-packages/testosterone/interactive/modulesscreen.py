import Queue
import curses
import logging

from testosterone.interactive.summary import Summary
from testosterone.interactive.utils import Spinner
from testosterone.interactive.utils import DoneScrolling


logger = logging.getLogger('testosterone.modulesscreen')


class ModulesScreen:
    """Represents the main module listing.

    UI-driven events:

        F5 -- refresh list of modules, resetting tests to un-run
        space -- run tests for selected module and submodules
        enter -- run selection

    """

    H = W = 0       # the dimensions of the window
    banner = " testosterone " # shows up at the top
    bottomrows = 3  # the number of boilerplate rows at the bottom
    selected = ''   # the dotted name of the currently selected item
    start = end = 0 # the current index positions in summary
    summary = {}    # a data dictionary per summarize()
    toprows = 3     # the number of boilerplate rows at the top
    viewrow = 0     # the current row selected in the viewport
    viewrows = 0    # the number of rows in the viewport
    win = None      # a curses window


    def __init__(self, iface):
        """Takes a CursesInterface object.
        """
        self.win = iface.win
        self.base = iface.base
        self.stopwords = iface.stopwords
        self.spinner = Spinner(self.spin)
        self.summary = Summary(self.stopwords)
        self.summary.refresh(self.base)
        if self.summary.names:
            self.selected = self.summary.names[self.start]

    def reload(self):
        self.summary = Summary(self.stopwords)
        self.spinner(self.summary.refresh, self.base)

    def get_size(self):
        """getmaxyx is 1-indexed, but just about everything else is 0-indexed.
        """
        return tuple([i-1 for i in self.win.getmaxyx()])

    def go(self):
        """Interact with the user, return the next screen.
        """

        while 1:

            # Draw the screen.
            # ================
            # But first make sure the terminal is big enough.

            if (self.H, self.W) != self.get_size():
                self.win.clear()
                self.win.refresh()
                self.H, self.W = self.get_size()
                if (self.H < 4) or (self.W < 34):
                    msg = "Terminal too small."
                    if (self.H == 0) or (self.W < len(msg)):
                        continue
                    self.win.addstr(self.H/2,(self.W-len(msg))/2,msg)
                    self.win.refresh()
                    continue
                self.draw()


            # Trap a key.
            # ===========
            # The first couple exit early, the rest want to redraw the list.

            c = self.win.getch()

            if c == ord('q'):
                raise KeyboardInterrupt
            elif c == ord('h'):
                continue # return HelpScreen(self.iface)

            if c == curses.KEY_UP:    # up
                self.scroll(1)
            elif c == curses.KEY_DOWN:  # down
                self.scroll(-1)
            elif c == curses.KEY_NPAGE: # page up
                self.scroll(-(self.viewrows*2)-1)
                self.viewrow = 0
            elif c == curses.KEY_PPAGE: # page down
                self.scroll((self.viewrows*2)-1)
                self.viewrow = 0
            elif c == curses.KEY_F5:    # F5
                self.reload()
            elif c == ord(' '):
                self.spinner(self.summary.refresh, self.selected, run=True)
            self.draw_list()


    def scroll_one(self, down=False):
        """Scroll the viewport up by one row, or down if down is True.
        """

        up = not down
        numrows = len(self.summary)-1

        if up: # scroll up
            if self.viewrow == 0: # top of viewport
                if self.start == 0: # top of list
                    raise DoneScrolling
                else: # not top of list
                    self.start -= 1
            else: # not top of viewport
                self.viewrow -= 1

        elif down: # scroll down
            if self.viewrow == numrows: # bottom of list
                raise DoneScrolling
            else: # not bottom of list
                if self.viewrow == self.viewrows: # bottom of viewport
                    self.start += 1
                else: # not bottom of viewport
                    self.viewrow += 1

        ints = self.viewrow, self.viewrows, self.start, numrows
        logger.debug(' '.join([str(i) for i in ints]))


    def scroll(self, delta):
        """Viewport scrolling.
        """
        down = delta < 0
        delta = abs(delta)
        try:
            for i in range(delta):
                self.scroll_one(down)
        except DoneScrolling:
            curses.beep()


    def spin(self):
        """Put a 'working' indicator in the banner.
        """
        l = (self.W - len(self.banner)) / 2
        stop = False
        while not stop:
            for i in range(4):
                spun = "  working%s  " % ('.'*i).ljust(3)
                self.win.addstr(0,l,spun,curses.A_BOLD)
                self.win.refresh()
                try:
                    stop = self.spinner.flag.get(timeout=0.25)
                except Queue.Empty:
                    pass
        self.draw_banner()


    def draw_banner(self):
        l = (self.W - len(self.banner)) / 2
        self.win.addstr(0,l,self.banner,curses.A_BOLD)


    def draw(self):
        """Draw the screen.
        """

        # Get window dimensions; account for border.
        # ==========================================

        H,W = self.H,self.W
        c1h = c2h = H - self.toprows - self.bottomrows
        c2w = 20
        c1w = W - c2w - 7
        self.c1 = (c1h, c1w)
        self.c2 = (c2h, c2w)
        self.viewrows = c1h


        # Background and border
        # =====================

        bold = curses.A_BOLD

        self.win.bkgd(' ')
        self.win.border() # not sure how to make this A_BOLD
        self.win.addch(0,0,curses.ACS_ULCORNER,bold)
        self.win.addch(0,W,curses.ACS_URCORNER,bold)
        self.win.addch(H,0,curses.ACS_LLCORNER,bold)
        #self.win.addch(H,W,curses.ACS_LRCORNER,bold) error! why?
        for i in range(1,W):
            self.win.addch(0,i,curses.ACS_HLINE,bold)
            self.win.addch(H,i,curses.ACS_HLINE,bold)
        for i in range(1,H):
            self.win.addch(i,0,curses.ACS_VLINE,bold)
            self.win.addch(i,W,curses.ACS_VLINE,bold)

        # headers bottom border
        self.win.addch(2,0,curses.ACS_LTEE,bold)
        for i in range(0,W-1):
            self.win.addch(2,i+1,curses.ACS_HLINE,bold)
        self.win.addch(2,W,curses.ACS_RTEE,bold)

        # footer top border
        self.win.addch(H-2,0,curses.ACS_LTEE,bold)
        for i in range(0,W-1):
            self.win.addch(H-2,i+1,curses.ACS_HLINE,bold)
        self.win.addch(H-2,W,curses.ACS_RTEE,bold)

        # column border
        bw = (W-c2w-3)
        self.win.addch(0,bw,curses.ACS_TTEE,bold)
        self.win.vline(1,bw,curses.ACS_VLINE,H-1,bold)
        self.win.addch(2,bw,curses.ACS_PLUS,bold)
        self.win.addch(H-2,bw,curses.ACS_PLUS,bold)
        self.win.addch(H,bw,curses.ACS_BTEE,bold)


        # Banner text and column headers
        # ==============================

        banner = " testosterone "
        l = (W - len(banner)) / 2
        r = l + len(banner)
        self.win.addch(0,l-2,curses.ACS_LARROW,bold)
        self.win.addch(0,l-1,curses.ACS_VLINE,bold)
        self.win.addstr(0,l,banner,bold)
        self.win.addch(0,r,curses.ACS_VLINE,bold)
        self.win.addch(0,r+1,curses.ACS_RARROW,bold)

        self.win.addstr(1,3,"MODULES",bold)
        self.win.addstr(1,self.W-c2w-1,"PASS",bold)
        self.win.addstr(1,self.W-c2w-1+5,"FAIL",bold)
        self.win.addstr(1,self.W-c2w-1+10," ERR",bold)
        self.win.addstr(1,self.W-c2w-1+15," ALL",bold)


        # Module listing
        # ==============
        # This calls self.win.refresh()

        self.draw_list()



    def draw_list(self):
        """Draw the list of modules.
        """

        c1h, c1w = self.c1
        c2h, c2w = self.c2

        # erase current listing
        for i in range(self.toprows+1, self.viewrows+self.toprows):
            self.win.addstr(i,1,' '*(c1w+2))
            self.win.addstr(i,c1w+5,' '*(c2w+2))

        if not self.summary.names:
            self.win.refresh()
            return

        prefix = '' # signal for submodule bullets
        displayed = []
        rownum = 0  # the row we are currently outputting
        self.end = self.start + self.viewrows + 1

        for i in range(self.start, self.end):

            name = self.summary.names[i]
            rownum = self.toprows + i - self.start

            ints = (self.start, self.end, rownum)
            logger.debug(' '.join([str(i) for i in ints]))

            pass5, fail, err, all, show, fresh = self.summary[name]

            displayed.append(name) # helps determine self.selected


            # Determine highlighting for this row.
            # ====================================

            has_tests = int(all) > 0

            if fresh is None and not has_tests:
                color = curses.color_pair(1)|curses.A_DIM
            elif fresh is None and has_tests:
                color = curses.color_pair(1)|curses.A_BOLD
            elif fresh is False:
                color = curses.color_pair(2)|curses.A_DIM
            elif fresh is True:
                color = curses.color_pair(2)|curses.A_BOLD


            # Short name, with indent.
            # ========================

            parts = name.split('.')
            shortname = ('  '*(len(parts)-1)) + parts[-1]
            if len(shortname) > c1w:
                shortname = shortname[:c1w-3] + '...'
            shortname = shortname.ljust(c1w)
            self.win.addstr(rownum,3,shortname,color)


            # Bullet(s)
            # =========

            l = ' '
            r = ' '
            a = curses.color_pair(3)|curses.A_BOLD
            if i == self.viewrow+self.toprows:
                if not prefix:
                    prefix = name
                l = curses.ACS_RARROW
                r = curses.ACS_LARROW
            elif prefix and name.startswith(prefix):
                l = r = curses.ACS_BULLET
            self.win.addch(rownum,1,l,a)
            self.win.addch(rownum,self.W-1,r,a)


            # Data
            # ====

            if pass5 == '-':
                pass5 = '- '
            if len(fail) > 4:
                fail = '9999'
            if len(err) > 4:
                err = '9999'
            if len(all) > 4:
                all = '9999'

            w = self.W-c2w-1
            self.win.addstr(rownum,w,pass5.rjust(4),color)
            self.win.addstr(rownum,w+5,err.rjust(4),color)
            self.win.addstr(rownum,w+10,fail.rjust(4),color)
            self.win.addstr(rownum,w+15,all.rjust(4),color)

            if i > len(self.summary)+1:
                break

        self.selected = displayed[self.viewrow]


        # Continuation indicators
        # =======================

        if self.start > 0:
            c = curses.ACS_UARROW
        else:
            c = curses.ACS_HLINE
        self.win.addch(2,1,c,curses.A_BOLD)
        self.win.addch(2,self.W-1,c,curses.A_BOLD)

        if self.end < len(self.summary):
            c = curses.ACS_LANTERN
        else:
            c = curses.ACS_HLINE
        self.win.addch(self.H,1,c,curses.A_BOLD)
        self.win.addch(self.H,self.W-1,c,curses.A_BOLD)


        # Totals
        # ======

        color = curses.color_pair(4)|curses.A_BOLD

        tpass5, tfail, terr, tall = self.summary.totals
        if tpass5 == '-':
            tpass5 = '- '
        if len(tfail) > 4:
            tfail = '9999'
        if len(terr) > 4:
            terr = '9999'
        if len(tall) > 4:
            tall = '9999'

        h = self.H-1
        w = self.W-c2w-1
        self.win.addstr(h,w,tpass5.rjust(4),color)
        self.win.addstr(h,w+5,terr.rjust(4),color)
        self.win.addstr(h,w+10,tfail.rjust(4),color)
        self.win.addstr(h,w+15,tall.rjust(4),color)


        # Finally, draw the window.
        # =========================

        self.win.refresh()
