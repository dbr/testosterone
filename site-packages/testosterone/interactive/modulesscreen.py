import Queue
import curses
import logging

from testosterone.interactive.summary import Summary
from testosterone.interactive.utils import Spinner, ScrollArea


logger = logging.getLogger('testosterone.modulesscreen')


class ModulesScreen:
    """Represents the main module listing.

    UI-driven events:

        F5 -- refresh list of modules, resetting tests to un-run
        space -- run tests for selected module and submodules
        enter -- run selection

    """

    H = W = 0               # the dimensions of the window
    banner = " testosterone " # shows up at the top
    bottomrows = 3          # the number of boilerplate rows at the bottom
    listing = None          # a ScrollArea
    selected = ''           # the dotted name of the currently selected item
    start = end = 0         # the current index positions in summary
    summary = {}            # a data dictionary per summarize()
    toprows = 3             # the number of boilerplate rows at the top
    viewrow = 0             # the current row selected in the viewport
    viewrows = 0            # the number of rows in the viewport
    win = None              # a curses window


    def __init__(self, iface):
        """Takes a CursesInterface object.
        """
        self.win = iface.win
        self.base = iface.base
        self.stopwords = iface.stopwords
        self.spinner = Spinner(self.spin)
        self.summary = Summary(self.stopwords)
        self.summary.refresh(self.base)
        if self.summary.names:
            self.selected = self.summary.names[self.start]


    # Main callable
    # =============

    def go(self):
        """Interact with the user, return the next screen.
        """

        while 1:

            # Draw the screen.
            # ================
            # But first make sure the terminal is big enough.

            if (self.H, self.W) != self.get_size():
                self.win.clear()
                self.win.refresh()
                self.H, self.W = self.get_size()
                if (self.H < 4) or (self.W < 34):
                    msg = "Terminal too small."
                    if (self.H == 0) or (self.W < len(msg)):
                        continue
                    self.win.addstr(self.H/2,(self.W-len(msg))/2,msg)
                    self.win.refresh()
                    continue
                self.draw()


            # Trap a key.
            # ===========
            # The first couple exit early, the rest want to redraw the list.

            c = self.win.getch()

            if c == ord('q'):
                raise KeyboardInterrupt
            elif c == ord('h'):
                continue # return HelpScreen(self.iface)

            if c == curses.KEY_UP:      # up
                self.listing.scroll(-1)
            elif c == curses.KEY_DOWN:  # down
                self.listing.scroll(1)
            elif c == curses.KEY_NPAGE: # page up
                self.listing.page_up()
            elif c == curses.KEY_PPAGE: # page down
                self.listing.page_down()
            elif c == curses.KEY_F5:    # F5
                self.reload()
            elif c == ord(' '):
                self.run()
            self.draw_list()


    # Helpers
    # =======

    def reload(self):
        self.summary = Summary(self.stopwords)
        self.spinner(self.summary.refresh, self.base)
        self.listing = self.scrollarea()

    def run(self):
        self.spinner(self.summary.refresh, self.selected, run=True)
        self.listing = self.scrollarea()

    def scrollarea(self):
        return ScrollArea( self.viewrows
                         , len(self.summary)
                         , self.toprows
                          )

    def get_size(self):
        """getmaxyx is 1-indexed, but just about everything else is 0-indexed.
        """
        return tuple([i-1 for i in self.win.getmaxyx()])


    def spin(self):
        """Put a 'working' indicator in the banner.

        This is called by our Spinner instance.

        """
        l = (self.W - len(self.banner)) / 2
        stop = False
        while not stop:
            for i in range(4):
                spun = "  working%s  " % ('.'*i).ljust(3)
                self.win.addstr(0,l,spun,curses.A_BOLD)
                self.win.refresh()
                try:
                    stop = self.spinner.flag.get(timeout=0.25)
                except Queue.Empty:
                    pass
        self.draw_banner()


    # Methods that actually write to the screen
    # =========================================

    def draw_banner(self):
        l = (self.W - len(self.banner)) / 2
        self.win.addstr(0,l,self.banner,curses.A_BOLD)


    def draw(self):
        """Draw the screen.
        """

        # Get window dimensions; account for border.
        # ==========================================

        H,W = self.H,self.W
        c1h = c2h = H - self.toprows - self.bottomrows
        c2w = 20
        c1w = W - c2w - 7
        self.c1 = (c1h, c1w)
        self.c2 = (c2h, c2w)
        self.viewrows = c1h


        # Background and border
        # =====================

        bold = curses.A_BOLD

        self.win.bkgd(' ')
        self.win.border() # not sure how to make this A_BOLD
        self.win.addch(0,0,curses.ACS_ULCORNER,bold)
        self.win.addch(0,W,curses.ACS_URCORNER,bold)
        self.win.addch(H,0,curses.ACS_LLCORNER,bold)
        #self.win.addch(H,W,curses.ACS_LRCORNER,bold) error! why?
        for i in range(1,W):
            self.win.addch(0,i,curses.ACS_HLINE,bold)
            self.win.addch(H,i,curses.ACS_HLINE,bold)
        for i in range(1,H):
            self.win.addch(i,0,curses.ACS_VLINE,bold)
            self.win.addch(i,W,curses.ACS_VLINE,bold)

        # headers bottom border
        self.win.addch(2,0,curses.ACS_LTEE,bold)
        for i in range(0,W-1):
            self.win.addch(2,i+1,curses.ACS_HLINE,bold)
        self.win.addch(2,W,curses.ACS_RTEE,bold)

        # footer top border
        self.win.addch(H-2,0,curses.ACS_LTEE,bold)
        for i in range(0,W-1):
            self.win.addch(H-2,i+1,curses.ACS_HLINE,bold)
        self.win.addch(H-2,W,curses.ACS_RTEE,bold)

        # column border
        bw = (W-c2w-3)
        self.win.addch(0,bw,curses.ACS_TTEE,bold)
        self.win.vline(1,bw,curses.ACS_VLINE,H-1,bold)
        self.win.addch(2,bw,curses.ACS_PLUS,bold)
        self.win.addch(H-2,bw,curses.ACS_PLUS,bold)
        self.win.addch(H,bw,curses.ACS_BTEE,bold)


        # Banner text and column headers
        # ==============================

        banner = " testosterone "
        l = (W - len(banner)) / 2
        r = l + len(banner)
        self.win.addch(0,l-2,curses.ACS_LARROW,bold)
        self.win.addch(0,l-1,curses.ACS_VLINE,bold)
        self.win.addstr(0,l,banner,bold)
        self.win.addch(0,r,curses.ACS_VLINE,bold)
        self.win.addch(0,r+1,curses.ACS_RARROW,bold)

        self.win.addstr(1,3,"MODULES",bold)
        self.win.addstr(1,self.W-c2w-1,"PASS",bold)
        self.win.addstr(1,self.W-c2w-1+5,"FAIL",bold)
        self.win.addstr(1,self.W-c2w-1+10," ERR",bold)
        self.win.addstr(1,self.W-c2w-1+15," ALL",bold)


        # Module listing
        # ==============
        # This calls self.win.refresh()

        self.listing = self.scrollarea()
        self.draw_list()


    def draw_list(self):
        """Draw the list of modules; called on almost every UI event.
        """

        c1h, c1w = self.c1
        c2h, c2w = self.c2


        # Erase current listing.
        # ======================

        for i in range(self.toprows, self.toprows+self.listing.numrows):
            self.win.addstr(i,1,' '*(c1w+2))
            self.win.addstr(i,c1w+5,' '*(c2w+2))


        # Write listing rows if we have any.
        # ==================================
        # parent is a signal for the submodule bullets logic.

        if self.listing.numitems == 0:
            self.win.refresh()
            return
        logger.debug(self.listing)
        parent = ''
        logger.debug(self.listing._ScrollArea__list())
        for index, rownum  in self.listing:
            parent = self.draw_row(index, rownum, parent)
        self.selected = self.summary.names[self.listing.selected]


        # Update continuation indicators.
        # ===============================

        if self.listing.start > 0:
            c = curses.ACS_UARROW
        else:
            c = curses.ACS_HLINE
        self.win.addch(2,1,c,curses.A_BOLD)
        self.win.addch(2,self.W-1,c,curses.A_BOLD)

        if self.listing.end < len(self.summary):
            c = curses.ACS_LANTERN
        else:
            c = curses.ACS_HLINE
        self.win.addch(self.H,1,c,curses.A_BOLD)
        self.win.addch(self.H,self.W-1,c,curses.A_BOLD)


        # Update totals.
        # ==============

        color = curses.color_pair(4)|curses.A_BOLD

        tpass5, tfail, terr, tall = self.summary.totals
        if tpass5 == '-':
            tpass5 = '- '
        if len(tfail) > 4:
            tfail = '9999'
        if len(terr) > 4:
            terr = '9999'
        if len(tall) > 4:
            tall = '9999'

        h = self.H-1
        w = self.W-c2w-1
        self.win.addstr(h,w,tpass5.rjust(4),color)
        self.win.addstr(h,w+5,terr.rjust(4),color)
        self.win.addstr(h,w+10,tfail.rjust(4),color)
        self.win.addstr(h,w+15,tall.rjust(4),color)


        # Finally, commit our writes.
        # ===========================

        self.win.refresh()


    def draw_row(self, index, rownum, parent):
        """Given two ints, write a row to the screen.

        The first int is the index into self.names. The second is the number of
        the row on the screen to write to. Both are 0-indexed.

        """

        c1h, c1w = self.c1
        c2h, c2w = self.c2

        name, pass5, fail, err, all, show, fresh = self.summary[index]


        # Determine highlighting for this row.
        # ====================================

        has_tests = int(all) > 0

        if fresh is None and not has_tests:
            color = curses.color_pair(1)|curses.A_DIM
        elif fresh is None and has_tests:
            color = curses.color_pair(1)|curses.A_BOLD
        elif fresh is False:
            color = curses.color_pair(2)|curses.A_DIM
        elif fresh is True:
            color = curses.color_pair(2)|curses.A_BOLD


        # Short name, with indent.
        # ========================

        parts = name.split('.')
        shortname = ('  '*(len(parts)-1)) + parts[-1]
        if len(shortname) > c1w:
            shortname = shortname[:c1w-3] + '...'
        shortname = shortname.ljust(c1w)
        self.win.addstr(rownum,3,shortname,color)


        # Bullet(s)
        # =========

        l = ' '
        r = ' '
        a = curses.color_pair(3)|curses.A_BOLD
        if index == self.listing.selected:
            if not parent:
                parent = name
            l = curses.ACS_RARROW
            r = curses.ACS_LARROW
        elif parent and name.startswith(parent):
            l = r = curses.ACS_BULLET
        self.win.addch(rownum,1,l,a)
        self.win.addch(rownum,self.W-1,r,a)


        # Data
        # ====

        if pass5 == '-':
            pass5 = '- '
        if len(fail) > 4:
            fail = '9999'
        if len(err) > 4:
            err = '9999'
        if len(all) > 4:
            all = '9999'

        w = self.W-c2w-1
        self.win.addstr(rownum,w,pass5.rjust(4),color)
        self.win.addstr(rownum,w+5,err.rjust(4),color)
        self.win.addstr(rownum,w+10,fail.rjust(4),color)
        self.win.addstr(rownum,w+15,all.rjust(4),color)

        return parent