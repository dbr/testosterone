import Queue
import curses
import logging

from testosterone.interactive.summary import Summary
from testosterone.interactive.utils import Spinner, ScrollArea


logger = logging.getLogger('testosterone.modulesscreen')


UI_CHARS = ( ord('q')
           , ord(' ')
           , curses.KEY_F5
           , curses.KEY_UP
           , curses.KEY_DOWN
           , curses.KEY_NPAGE
           , curses.KEY_PPAGE
           , curses.KEY_HOME
           , curses.KEY_END
            )


class ModulesScreen:
    """Represents the main module listing.

    UI-driven events:

        F5 -- refresh list of modules, resetting tests to un-run
        space -- run tests for selected module and submodules
        enter -- run selection

    """

    H = W = 0               # the dimensions of the window
    banner = " testosterone " # shows up at the top
    bottomrows = 3          # the number of boilerplate rows at the bottom
    listing = None          # a ScrollArea
    selected = ''           # the dotted name of the currently selected item
    start = end = 0         # the current index positions in summary
    summary = {}            # a data dictionary per summarize()
    toprows = 3             # the number of boilerplate rows at the top
    viewrow = 0             # the current row selected in the viewport
    win = None              # a curses window


    def __init__(self, iface):
        """Takes a CursesInterface object.
        """
        self.win = iface.win
        self.base = iface.base
        self.stopwords = iface.stopwords
        self.spinner = Spinner(self.spin)
        self.summary = Summary(self.stopwords)
        self.summary.refresh(self.base)
        if self.summary.names:
            self.selected = self.summary.names[self.start]


    # Main callable
    # =============

    def go(self):
        """Interact with the user, return the next screen.
        """

        while 1:

            # React to UI events, including resizes.
            # ======================================

            H, W = self.get_size()

            if (H <= 5) or (W <= 34): # terminal is too small
                self.win.clear()
                self.win.refresh()
                msg = "Terminal too small."
                if (H == 0) or (W < len(msg)):
                    continue
                self.win.addstr(H/2,(W-len(msg))/2,msg)
                self.win.refresh()
                c = self.win.getch()
                if c == ord('q'):
                    raise KeyboardInterrupt
                continue

            elif (self.H, self.W) != (H, W): # terminal has been resized
                self.win.clear()
                self.win.refresh()
                self.H, self.W = (H, W)
                c1h = c2h = H - self.toprows - self.bottomrows
                c2w = 20
                c1w = W - c2w - 7
                self.c1 = (c1h, c1w)
                self.c2 = (c2h, c2w)
                self.draw()

            else: # react to key presses
                c = self.win.getch()
                if c in UI_CHARS:
                    self.react(c)
                    self.draw_list()


    # Helpers
    # =======

    def react(self, c):
        """Given a keypress event, do something.

        The first couple exit early, the rest want to redraw the list.

        """

        if c == ord('q'):
            raise KeyboardInterrupt
        elif c == ord('h'):
            return # return HelpScreen(self.iface)


        # NB: page_up() and page_down() are switched because of observed
        # behavior. I don't know if this is a quirk of my terminal or
        # an error in ScrollArea or what. Also, I haven't observed the
        # home() and down() functions in action. Again, probably a
        # terminal quirk. UPDATE: Actually, I think it might be an error
        # in the curses docs.

        if c == curses.KEY_UP:      # up
            self.listing.scroll(-1)
        elif c == curses.KEY_DOWN:  # down
            self.listing.scroll(1)
        elif c == curses.KEY_PPAGE: # page up
            self.listing.page_up()
        elif c == curses.KEY_NPAGE: # page down
            self.listing.page_down()
        elif c == curses.KEY_HOME:  # home
            self.listing.home()
        elif c == curses.KEY_END:   # down
            self.listing.end()
        elif c == curses.KEY_F5:    # F5
            self.reload()
        elif c == ord(' '):
            self.run()


    def reload(self):
        self.summary = Summary(self.stopwords)
        self.spinner(self.summary.refresh, self.base)
        self.listing = self.scrollarea()


    def run(self):
        self.spinner(self.summary.refresh, self.selected, run=True)


    def scrollarea(self):
        return ScrollArea(self.c1[0]+1, len(self.summary), self.toprows)


    def get_size(self):
        """getmaxyx is 1-indexed, but just about everything else is 0-indexed.
        """
        H, W = self.win.getmaxyx()
        return (H-1, W-1)


    def spin(self):
        """Put a 'working' indicator in the banner.

        This is called by our Spinner instance.

        """
        l = (self.W - len(self.banner)) / 2
        stop = False
        while not stop:
            for i in range(4):
                spun = "  working%s  " % ('.'*i).ljust(3)
                self.win.addstr(0,l,spun,curses.A_BOLD)
                self.win.refresh()
                try:
                    stop = self.spinner.flag.get(timeout=0.25)
                except Queue.Empty:
                    pass
        self.draw_banner()


    # Methods that actually write to the screen
    # =========================================

    def draw_banner(self):
        l = (self.W - len(self.banner)) / 2
        self.win.addstr(0,l,self.banner,curses.A_BOLD)


    def draw(self):
        """Draw the screen.
        """

        H, W = self.H, self.W
        c1h, c1w = self.c1
        c2h, c2w = self.c2


        # Background and border
        # =====================

        bold = curses.A_BOLD

        self.win.bkgd(' ')
        self.win.border() # not sure how to make this A_BOLD
        self.win.addch(0,0,curses.ACS_ULCORNER,bold)
        self.win.addch(0,W,curses.ACS_URCORNER,bold)
        self.win.addch(H,0,curses.ACS_LLCORNER,bold)
        #self.win.addch(H,W,curses.ACS_LRCORNER,bold) error! why?
        for i in range(1,W):
            self.win.addch(0,i,curses.ACS_HLINE,bold)
            self.win.addch(H,i,curses.ACS_HLINE,bold)
        for i in range(1,H):
            self.win.addch(i,0,curses.ACS_VLINE,bold)
            self.win.addch(i,W,curses.ACS_VLINE,bold)

        # headers bottom border
        self.win.addch(2,0,curses.ACS_LTEE,bold)
        for i in range(0,W-1):
            self.win.addch(2,i+1,curses.ACS_HLINE,bold)
        self.win.addch(2,W,curses.ACS_RTEE,bold)

        # footer top border
        self.win.addch(H-2,0,curses.ACS_LTEE,bold)
        for i in range(0,W-1):
            self.win.addch(H-2,i+1,curses.ACS_HLINE,bold)
        self.win.addch(H-2,W,curses.ACS_RTEE,bold)

        # column border
        bw = (W-c2w-3)
        self.win.addch(0,bw,curses.ACS_TTEE,bold)
        self.win.vline(1,bw,curses.ACS_VLINE,H-1,bold)
        self.win.addch(2,bw,curses.ACS_PLUS,bold)
        self.win.addch(H-2,bw,curses.ACS_PLUS,bold)
        self.win.addch(H,bw,curses.ACS_BTEE,bold)


        # Banner text and column headers
        # ==============================

        banner = " testosterone "
        l = (W - len(banner)) / 2
        r = l + len(banner)
        self.win.addch(0,l-2,curses.ACS_LARROW,bold)
        self.win.addch(0,l-1,curses.ACS_VLINE,bold)
        self.win.addstr(0,l,banner,bold)
        self.win.addch(0,r,curses.ACS_VLINE,bold)
        self.win.addch(0,r+1,curses.ACS_RARROW,bold)

        self.win.addstr(1,3,"MODULES",bold)
        self.win.addstr(1,self.W-c2w-1,"PASS",bold)
        self.win.addstr(1,self.W-c2w-1+5,"FAIL",bold)
        self.win.addstr(1,self.W-c2w-1+10," ERR",bold)
        self.win.addstr(1,self.W-c2w-1+15," ALL",bold)


        # Module listing
        # ==============
        # This calls self.win.refresh()

        self.listing = self.scrollarea()
        self.draw_list()


    def draw_list(self):
        """Draw the list of modules; called on almost every UI event.
        """

        c1h, c1w = self.c1
        c2h, c2w = self.c2
        longname = self.selected


        # Erase current listing.
        # ======================

        for i in range(self.toprows, self.toprows+self.listing.numrows):
            self.win.addstr(i,1,' '*(c1w+2))
            self.win.addstr(i,c1w+5,' '*(c2w+2))


        # Write listing rows if we have any.
        # ==================================
        # parent is a signal for the submodule bullets logic.

        if self.listing.numitems != 0:
            logger.debug(self.listing)
            parent = ''
            for index, rownum  in self.listing:
                parent = self.draw_row(index, rownum, parent)
            self.selected = self.summary.names[self.listing.curitem]


        # Update continuation indicators.
        # ===============================

        if self.listing.start > 0:
            c = curses.ACS_UARROW
        else:
            c = curses.ACS_HLINE
        self.win.addch(2,1,c,curses.A_BOLD)
        self.win.addch(2,self.W-1,c,curses.A_BOLD)
        if self.listing.end_ < self.listing.numitems:
            c = curses.ACS_LANTERN
        else:
            c = curses.ACS_HLINE
        h = self.toprows + 1 + c1h
        self.win.addch(h,1,c,curses.A_BOLD)
        self.win.addch(h,self.W-1,c,curses.A_BOLD)


        # Update totals.
        # ==============

        tpass5, tfail, terr, tall = self.summary.totals
        if tpass5 == '-':
            tpass5 = '- '
        if len(tfail) > 4:
            tfail = '9999'
        if len(terr) > 4:
            terr = '9999'
        if len(tall) > 4:
            tall = '9999'

        white = curses.color_pair(1)|curses.A_BOLD
        red = curses.color_pair(2)|curses.A_BOLD
        green = curses.color_pair(3)|curses.A_BOLD

        if not '%' in tpass5:
            color = white
        elif int(tfail) or int(terr):
            color = red
        else:
            color = green

        h = self.toprows + 1 + c1h + 1
        w = self.W-c2w-1
        self.win.addstr(h,w,tpass5.rjust(4),color)
        self.win.addstr(h,w+5,terr.rjust(4),color)
        self.win.addstr(h,w+10,tfail.rjust(4),color)
        self.win.addstr(h,w+15,tall.rjust(4),color)

        base = self.summary.base
        if len(base) > c1w:
            base = base[:c1w-3] + '...'
        base = base.ljust(c1w)
        self.win.addstr(h,3,base,color)


        # Finally, commit our writes.
        # ===========================

        self.win.refresh()


    def draw_row(self, index, rownum, parent):
        """Given two ints, write a row to the screen.

        The first int is the index into self.names. The second is the number of
        the row on the screen to write to. Both are 0-indexed.

        """

        c1h, c1w = self.c1
        c2h, c2w = self.c2

        name, pass5, fail, err, all, show, fresh = self.summary[index]


        # Determine highlighting for this row.
        # ====================================

        has_tests = int(all)
        has_flops = (fresh is not None) and (int(fail) or int(err))

        white       = curses.color_pair(1)|curses.A_BOLD
        grey        = curses.color_pair(1)|curses.A_DIM
        red         = curses.color_pair(2)|curses.A_BOLD
        dark_red    = curses.color_pair(2)|curses.A_DIM
        green       = curses.color_pair(3)|curses.A_BOLD
        dark_green  = curses.color_pair(3)|curses.A_DIM

        if fresh is None and not has_tests:
            color = grey
        elif fresh is None and has_tests:
            color = white
        elif fresh:
            if has_flops:
                color = red
            else:
                color = green
        elif not fresh:
            if has_flops:
                color = dark_red
            else:
                color = dark_green


        # Short name, with indent.
        # ========================

        i = len('.'.join(self.base.split('.')[:-1]))
        parts = name[i:].lstrip('.').split('.')
        shortname = ('  '*(len(parts)-1)) + parts[-1]
        if len(shortname) > c1w:
            shortname = shortname[:c1w-3] + '...'
        shortname = shortname.ljust(c1w)
        self.win.addstr(rownum,3,shortname,color)


        # Bullet(s)
        # =========

        l = ' '
        r = ' '
        a = curses.color_pair(4)|curses.A_BOLD
        if index == self.listing.curitem:
            if not parent:
                parent = name
            l = curses.ACS_RARROW
            r = curses.ACS_LARROW
        elif parent and name.startswith(parent):
            l = r = curses.ACS_BULLET
        self.win.addch(rownum,1,l,a)
        self.win.addch(rownum,self.W-1,r,a)


        # Data
        # ====

        if not int(all):
            pass5 = fail = err = '-'

        if pass5 == '-':
            pass5 = '- '
        if len(fail) > 4:
            fail = '9999'
        if len(err) > 4:
            err = '9999'
        if len(all) > 4:
            all = '9999'

        w = self.W-c2w-1
        self.win.addstr(rownum,w,pass5.rjust(4),color)
        self.win.addstr(rownum,w+5,err.rjust(4),color)
        self.win.addstr(rownum,w+10,fail.rjust(4),color)
        self.win.addstr(rownum,w+15,all.rjust(4),color)

        return parent
