import Queue
import curses
import logging
import traceback
from curses import ascii

from testosterone.interactive.detail import Detail, RefreshError
from testosterone.interactive.utils import Spinner, ScrollArea
from testosterone.interactive.screens.base import BaseScreen


logger = logging.getLogger('testosterone.screens.detail')


class DetailScreen(BaseScreen):
    """This screen presents an interface to the detail report.
    """

    banner = " testosterone " # shows up at the top
    bottomrows = 3  # the number of boilerplate rows at the bottom
    toprows = 3     # the number of boilerplate rows at the top of the screen
    focus = 'result' # the currently selected ScrollArea: tests/result
    tests = None    # the left ScrollArea
    result = None   # the right ScrollArea
    detail = None   # a Detail instance
    curresult = ()  # list of lines in the currently displayed result text
    selected = ''   # the name of the currently selected test


    def __init__(self, summary):
        """Takes a dotted module name.
        """
        self.summary = summary
        self.win = summary.win
        self.base = summary.selected
        self.colors = summary.colors
        self.spinner = Spinner(self.spin)
        self.detail = Detail(self.base)
        if self.detail.names:
            self.selected = self.detail.names[0]


    # BaseScreen contracts
    # ====================

    ui_chars = ( ord('q')
               , ord(' ')
               , curses.KEY_F5
               , curses.KEY_BACKSPACE
               , curses.KEY_ENTER
               , curses.KEY_UP
               , curses.KEY_DOWN
               , curses.KEY_PPAGE
               , curses.KEY_NPAGE
               , curses.KEY_HOME
               , curses.KEY_END
               , ascii.TAB
               , ascii.LF
               , ascii.ESC
                )

    def resize(self):
        c1h = c2h = self.H - self.toprows - self.bottomrows
        c1w = (self.W/2) - 5
        c2w = self.W - c1w - 5 - 3
        self.c1 = (c1h, c1w)
        self.c2 = (c2h, c2w)
        self.draw_frame()
        self.spinner(self.detail.refresh)
        self.tests = ScrollArea(c1h, len(self.detail), self.toprows)
        self.update_curresult()
        self.draw_content()

    def react(self, c):

        if c == ord('q'):
            raise KeyboardInterrupt

        if c in (ord('q'), curses.KEY_BACKSPACE, ascii.ESC):
            return self.summary
        elif c == ord('h'):
            return # return HelpScreen(self.iface)

        if c in (curses.KEY_F5, curses.KEY_ENTER, ascii.LF, ord(' ')):
            self.spinner(self.detail.refresh)
            if self.selected not in self.detail.names:
                self.selected = ''
            self.update_curresult()
            self.draw_content()
            return

        if c == ascii.TAB:
            self.focus = (self.focus == 'result') and 'tests' or 'result'

        if self.focus == 'tests':
            if c == curses.KEY_UP:      # up
                self.tests.scroll(-1)
            elif c == curses.KEY_DOWN:  # down
                self.tests.scroll(1)
            elif c == curses.KEY_PPAGE: # page up
                self.tests.page_up()
            elif c == curses.KEY_NPAGE: # page down
                self.tests.page_down()
            elif c == curses.KEY_HOME:  # home
                self.tests.home()
            elif c == curses.KEY_END:   # down
                self.tests.end()
        else:
            if c == curses.KEY_UP:      # up
                self.result.move_cursor(0)
                self.result.scroll(-1)
            elif c == curses.KEY_DOWN:  # down
                self.result.move_cursor(self.result.numrows-1)
                self.result.scroll(1)
            elif c == curses.KEY_PPAGE: # page up
                self.result.page_up()
            elif c == curses.KEY_NPAGE: # page down
                self.result.page_down()

        self.draw_content()


    # Helpers
    # =======

    def spin(self):
        """Put a 'working' indicator in the banner.

        This is called by our Spinner instance.

        """
        l = (self.W - len(self.banner)) / 2
        stop = False
        while not stop:
            for i in range(4):
                spun = "  working%s  " % ('.'*i).ljust(3)
                self.win.addstr(0,l,spun,self.colors.BLUE)
                self.win.refresh()
                try:
                    stop = self.spinner.flag.get(timeout=0.25)
                except Queue.Empty:
                    pass
        self.draw_banner()

    def update_curresult(self):
        if self.selected == '':
            result = self.detail.result
        else:
            result = self.detail.data[self.selected][1]
        self.curresult = self.format_result(result)
        self.result = ScrollArea(self.c1[0], len(self.curresult), self.toprows)


    def format_result(self, result):
        """Given a unittest result, format it for our pane.
        """
        return [i[:self.c2[1]] for i in result.splitlines()]
        wrapper_1.width = wrapper_2.width = self.W-1
        raw = traceback_.splitlines()
        lines = wrapper_1.wrap(raw[0])
        lines.append('')
        for line in raw[1:-1]:
            line = line.strip()
            lines.extend(wrapper_2.wrap(line))
            if not line.startswith('File'):
                lines.append('')
        lines.extend(wrapper_1.wrap(raw[-1]))
        return lines


    # Writers
    # =======

    def draw_banner(self):
        l = (self.W - len(self.banner)) / 2
        self.win.addstr(0,l,self.banner,self.colors.BLUE_DIM)


    def draw_frame(self):
        """Draw the screen.
        """

        H, W = self.H, self.W
        c1h, c1w = self.c1
        c2h, c2w = self.c2


        # Background and border
        # =====================

        color = self.colors.WHITE

        self.win.bkgd(' ')
        self.win.border() # not sure how to make this A_BOLD
        self.win.addch(0,0,curses.ACS_ULCORNER,color)
        self.win.addch(0,W,curses.ACS_URCORNER,color)
        self.win.addch(H,0,curses.ACS_LLCORNER,color)
        #self.win.addch(H,W,curses.ACS_LRCORNER,color) error! why?
        for i in range(1,W):
            self.win.addch(0,i,curses.ACS_HLINE,color)
            self.win.addch(H,i,curses.ACS_HLINE,color)
        for i in range(1,H):
            self.win.addch(i,0,curses.ACS_VLINE,color)
            self.win.addch(i,W,curses.ACS_VLINE,color)

        # headers bottom border
        self.win.addch(2,0,curses.ACS_LTEE,color)
        for i in range(0,W-1):
            self.win.addch(2,i+1,curses.ACS_HLINE,color)
        self.win.addch(2,W,curses.ACS_RTEE,color)

        # footer top border
        self.win.addch(H-2,0,curses.ACS_LTEE,color)
        for i in range(0,W-1):
            self.win.addch(H-2,i+1,curses.ACS_HLINE,color)
        self.win.addch(H-2,W,curses.ACS_RTEE,color)

        # column border
        bw = c1w+5
        self.win.vline(3,bw,curses.ACS_VLINE,H-5,color)
        self.win.addch(2,bw,curses.ACS_TTEE,color)
        self.win.addch(H-2,bw,curses.ACS_BTEE,color)


        # Banner text and column headers
        # ==============================

        l = (W - len(self.banner)) / 2
        r = l + len(self.banner)
        self.win.addch(0,l-2,curses.ACS_LARROW,color)
        self.win.addch(0,l-1,curses.ACS_VLINE,color)
        self.draw_banner()
        self.win.addch(0,r,curses.ACS_VLINE,color)
        self.win.addch(0,r+1,curses.ACS_RARROW,color)

        base = self.base
        if len(base) > c1w:
            base = base[:c1w-3] + '...'
        base = base.ljust(c1w)
        self.win.addstr(self.H-1,3,base,self.colors.GRAY)


        # Commit our changes.
        # ===================

        self.win.refresh()


    def draw_content(self):
        """Erase the current listing and redraw.
        """

        c1h, c1w = self.c1
        c2h, c2w = self.c2


        # Erase and redraw rows.
        # ======================

        for i in range(self.toprows, self.toprows+self.tests.numrows+1):
            self.win.addstr(i,1,' '*(c1w+4))
            self.win.addstr(i,c1w+6,' '*(c2w+2))
        if self.tests.numitems != 0:
            for index, rownum  in self.tests:
                self.draw_row(index, rownum)
            selected = ''
            if self.focus == 'tests':
                self.selected = self.detail.names[self.tests.curitem]
            self.update_curresult()


        # Result
        # ======

        color = self.colors.GRAY
        if self.focus == 'result':
            color = self.colors.WHITE
        for index, rownum in self.result:
            self.win.addstr(rownum,c1w+7,self.curresult[index],color)


        # Commit changes.
        # ===============

        self.win.refresh()


    def draw_row(self, index, rownum):
        """Given two ints, write a row to the screen.

        The first int is the index into self.names. The second is the number of
        the row on the screen to write to. Both are 0-indexed.

        """

        c1h, c1w = self.c1
        c2h, c2w = self.c2

        name, flub, result = self.detail[index]


        # Determine highlighting for this row.
        # ====================================

        if self.focus == 'result':
            bullet_color = self.colors.BLUE_DIM
            if flub == 'error':
                color = self.colors.YELLOW_DIM
            elif flub == 'failure':
                color = self.colors.RED_DIM
            else:
                color = self.colors.WHITE_DIM
        else:
            bullet_color = self.colors.BLUE
            if flub == 'error':
                color = self.colors.YELLOW
            elif flub == 'failure':
                color = self.colors.RED
            else:
                color = self.colors.WHITE


        # Test name and bullets
        # =====================

        if len(name) > c1w:
            name = name[:c1w-3] + '...'
        name = name.ljust(c1w)
        self.win.addstr(rownum,3,name,color)

        l = ' '
        r = ' '
        if index == self.tests.curitem:
            l = curses.ACS_RARROW
            r = curses.ACS_LARROW
        self.win.addch(rownum,1,l,bullet_color)
        self.win.addch(rownum,c1w+4,r,bullet_color)

