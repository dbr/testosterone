import Queue
import curses
import logging
import traceback
from curses import ascii

from testosterone.interactive.detail import Detail, RefreshError
from testosterone.interactive.utils import Spinner, ScrollArea
from testosterone.interactive.screens.base import BaseScreen


logger = logging.getLogger('testosterone.screens.detail')


class DetailScreen(BaseScreen):
    """This screen presents an interface to the detail report.
    """

    banner = " testosterone " # shows up at the top
    bottomrows = 3  # the number of boilerplate rows at the bottom
    toprows = 3     # the number of boilerplate rows at the top of the screen
    pane = None     # the currently selected ScrollArea: tests/results
    area_tests = None   # the left ScrollArea
    area_result = None  # the right ScrollArea
    detail = None   # a Detail instance
    result = ()     # list of lines in the currently displayed result text
    selected = ''   # the name of the currently selected test


    def __init__(self, summary):
        """Takes a dotted module name.
        """
        self.screen = summary
        self.win = summary.win
        self.base = summary.selected
        self.colors = summary.colors
        self.spinner = Spinner(self.spin)
        self.detail = Detail(self.base)
        self.refresh()
        logger.debug(self.detail.result)
        if self.detail.names:
            self.selected = self.detail.names[0]


    # BaseScreen contracts
    # ====================

    ui_chars = ( ord('q')
               , ord(' ')
               , curses.KEY_ENTER
               , curses.KEY_F5
                )

    def resize(self):
        c1h = c2h = self.H - self.toprows - self.bottomrows
        c1w = 60
        c2w = self.W - c1w - 7
        self.c1 = (c1h, c1w)
        self.c2 = (c2h, c2w)
        self.area_tests = ScrollArea(c1h, len(self.detail), self.toprows)
        self.area_result = ScrollArea(c1h, len(self.result), self.toprows)
        self.draw_frame()

    def react(self, c):

        if c == ord('q'):
            raise KeyboardInterrupt
        elif c == ord('h'):
            return # return HelpScreen(self.iface)

        elif c in (curses.KEY_F5, curses.KEY_ENTER, ord(' ')):
            self.spinner(self.refresh)

        self.draw_tests()


    # Helpers
    # =======

    def refresh(self):
        self.detail.refresh()
        self.result = self.detail.result.splitlines()

    def spin(self):
        """Put a 'working' indicator in the banner.

        This is called by our Spinner instance.

        """
        l = (self.W - len(self.banner)) / 2
        stop = False
        while not stop:
            for i in range(4):
                spun = "  working%s  " % ('.'*i).ljust(3)
                self.win.addstr(0,l,spun,self.colors.GREEN)
                self.win.refresh()
                try:
                    stop = self.spinner.flag.get(timeout=0.25)
                except Queue.Empty:
                    pass
        self.draw_banner()


    # Writers
    # =======

    def draw_banner(self):
        l = (self.W - len(self.banner)) / 2
        self.win.addstr(0,l,self.banner,self.colors.BLUE)


    def draw_frame(self):
        """Draw the screen.
        """

        H, W = self.H, self.W
        c1h, c1w = self.c1
        c2h, c2w = self.c2


        # Background and border
        # =====================

        bold = curses.A_BOLD

        self.win.bkgd(' ')
        self.win.border() # not sure how to make this A_BOLD
        self.win.addch(0,0,curses.ACS_ULCORNER,bold)
        self.win.addch(0,W,curses.ACS_URCORNER,bold)
        self.win.addch(H,0,curses.ACS_LLCORNER,bold)
        #self.win.addch(H,W,curses.ACS_LRCORNER,bold) error! why?
        for i in range(1,W):
            self.win.addch(0,i,curses.ACS_HLINE,bold)
            self.win.addch(H,i,curses.ACS_HLINE,bold)
        for i in range(1,H):
            self.win.addch(i,0,curses.ACS_VLINE,bold)
            self.win.addch(i,W,curses.ACS_VLINE,bold)

        # headers bottom border
        self.win.addch(2,0,curses.ACS_LTEE,bold)
        for i in range(0,W-1):
            self.win.addch(2,i+1,curses.ACS_HLINE,bold)
        self.win.addch(2,W,curses.ACS_RTEE,bold)

        # footer top border
        self.win.addch(H-2,0,curses.ACS_LTEE,bold)
        for i in range(0,W-1):
            self.win.addch(H-2,i+1,curses.ACS_HLINE,bold)
        self.win.addch(H-2,W,curses.ACS_RTEE,bold)

        # column border
        bw = (W-c2w-3)
        self.win.addch(0,bw,curses.ACS_TTEE,bold)
        self.win.vline(1,bw,curses.ACS_VLINE,H-1,bold)
        self.win.addch(2,bw,curses.ACS_PLUS,bold)
        self.win.addch(H-2,bw,curses.ACS_PLUS,bold)
        self.win.addch(H,bw,curses.ACS_BTEE,bold)


        # Banner text and column headers
        # ==============================

        l = (W - len(self.banner)) / 2
        r = l + len(self.banner)
        self.win.addch(0,l-2,curses.ACS_LARROW,bold)
        self.win.addch(0,l-1,curses.ACS_VLINE,bold)
        self.draw_banner()
        self.win.addch(0,r,curses.ACS_VLINE,bold)
        self.win.addch(0,r+1,curses.ACS_RARROW,bold)

        #self.win.addstr(1,3,"MODULES",bold)
        #self.win.addstr(1,self.W-c2w-1,"PASS",bold)
        #self.win.addstr(1,self.W-c2w-1+5,"FAIL",bold)
        #self.win.addstr(1,self.W-c2w-1+10," ERR",bold)
        #self.win.addstr(1,self.W-c2w-1+15," ALL",bold)


        # Listing and result panes
        # ========================
        # This calls self.win.refresh()

        self.draw_tests()


    def draw_tests(self):
        """Draw the list of tests.
        """

        c1h, c1w = self.c1
        c2h, c2w = self.c2
        longname = self.selected
        pane = self.area_tests

        # Erase current pane.
        # ======================

        for i in range(self.toprows, self.toprows+pane.numrows):
            self.win.addstr(i,1,' '*(c1w+2))
            self.win.addstr(i,c1w+5,' '*(c2w+2))


        # Write rows if we have any.
        # ==========================

        if pane.numitems != 0:
            for index, rownum  in pane:
                self.draw_row(index, rownum)
            self.selected = self.detail.names[pane.curitem]


        # Finally, commit our writes.
        # ===========================

        self.draw_result()


    def draw_row(self, index, rownum):
        """Given two ints, write a row to the screen.

        The first int is the index into self.names. The second is the number of
        the row on the screen to write to. Both are 0-indexed.

        """

        c1h, c1w = self.c1
        c2h, c2w = self.c2

        name, flub, result = self.detail[index]


        # Determine highlighting for this row.
        # ====================================


        if flub == 'error':
            color = self.colors.YELLOW
        elif flub == 'failure':
            color = self.colors.RED
        else:
            color = self.colors.GRAY


        # Test name
        # =========

        if len(name) > c1w:
            name = name[:c1w-3] + '...'
        name = name.ljust(c1w)
        self.win.addstr(rownum,3,name,color)


        # Bullet(s)
        # =========

        l = ' '
        r = ' '
        if index == self.area_tests.curitem:
            l = curses.ACS_RARROW
            r = curses.ACS_LARROW
        self.win.addch(rownum,1,l,self.colors.BLUE)
        self.win.addch(rownum,self.W-1,r,self.colors.BLUE)


        # Data
        # ====

        #if not int(all):
        #    pass5 = fail = err = '-'
        #
        #if pass5 == '-':
        #    pass5 = '- '
        #if len(fail) > 4:
        #    fail = '9999'
        #if len(err) > 4:
        #    err = '9999'
        #if len(all) > 4:
        #    all = '9999'
        #
        #w = self.W-c2w-1
        #self.win.addstr(rownum,w,pass5.rjust(4),color)
        #self.win.addstr(rownum,w+5,err.rjust(4),color)
        #self.win.addstr(rownum,w+10,fail.rjust(4),color)
        #self.win.addstr(rownum,w+15,all.rjust(4),color)


    def draw_result(self):
        """
        """
        c1w, c1h = self.c1
        c2w, c2h = self.c2
        for index, rownum in self.area_result:
            self.win.addstr(rownum,c1w+c2w+3,self.result[index])
        self.win.refresh()
