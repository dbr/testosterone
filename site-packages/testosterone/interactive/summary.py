import subprocess
import sys


class Summary:
    """Represent the data from an inter-process summarize() call.
    """

    data = []   # a dictionary, {name:<6-tuples>}:
                #   0-3 summarize() data: pass5, fail, err, all
                #   4   bool; whether to show this item
                #   5   None/False/True; whether the data is recent
    totals = () # a single 4-tuple per summarize()
    names = []  # a list of names for which show is True

    def __init__(self, stopwords=()):
        """Takes a dotted name, a list, and two booleans.
        """
        self.stopwords = stopwords
        self.data = {}
        self.total = []
        self.names = []

    def __getitem__(self, key):
        return self.data[key]

    def __len__(self):
        """Only count items for which show is True.
        """
        return len([v for v in self.data.values() if v[4]])

    def __iter__(self):
        return self.data.__iter__()
    iterkeys = __iter__


    def refresh(self, base, run=False):
        """Update our information.
        """

        # Mark currently fresh data as stale.
        # ===================================

        for name, datum in self.data.iteritems():
            if datum[5] is True:
                datum[5] = False


        # Make the call.
        # ==============

        call = ( sys.executable
               , sys.argv[0]
               , '--stopwords=%s' % ','.join(self.stopwords)
               , run and '--run' or '--find'
               , '--scripted'
               , '--summary'
               , '--verbose' # always verbose; deal with empties higher up
               , base
                )
        proc = subprocess.Popen(call, stdout=subprocess.PIPE)
        logger.debug(' '.join(call))


        # Total
        # =====

        lines = proc.stdout.read().splitlines()
        self.totals = lines[-1].split()[1:]
        del lines[-1]


        # Data
        # ====
        # Besides our own formatting, we also need to ignore any program output
        # that preceded our report.

        start = False
        for line in lines:

            # Decide if we want this line, and if so, split it on spaces.
            # ===========================================================

            line = line.strip('\n')
            if line == BANNER:
                start = True
                continue
            if (not start) or (not line) or line in (HEADERS, BORDER):
                continue
            tokens = line.split()


            # Convert the row to our record format.
            # =====================================
            # The tricky part is deciding whether to show this row: we want to
            # list modules that have non-passing tests, or that have submodules
            # with non-passing tests. Since data is coming to us ordered, we
            # can count on ancestor modules already being in self.data by the
            # time we get to a module with non-passing tests.

            name = tokens[0]
            stats = tokens[1:]

            has_tests = int(stats[3]) > 0

            fresh = None
            if has_tests and ('-' not in stats):
                fresh = True

            show = False
            if has_tests and (stats[0] != '100%'):
                show = True
                parts = name.split('.')[:-1]
                for i in range(len(parts),0,-1):
                    _name = '.'.join(parts[:i])
                    self.data[_name][4] = True

            self.data[name] = stats + [show, fresh]


        # Store a sorted list of our keys.
        # ================================

        self.names = sorted([n for n in self.data if self.data[n][4]])



import unittest

if '--foo' in sys.argv:
    foo = Summary(('_zope','jon'))
    foo.refresh('httpy')
    import pdb; pdb.set_trace()
    raise SystemExit
