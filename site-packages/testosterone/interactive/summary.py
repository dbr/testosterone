import logging
import os
import subprocess
import sys

from testosterone.cli.utils import BANNER, BORDER, HEADERS
from testosterone.interactive.utils import RefreshError


logger = logging.getLogger('testosterone.interactive.summary')


class Summary:
    """Represent the data from an inter-process summarize() call.

    This is designed to be a persistent object. Repeated calls to refresh will
    update the dataset. On partial updates, existing data will be marked as
    stale. There is also a show flag for each record; only items for which this
    are true are included in the name index and __len__ calls.

    """

    base = ''       # the current base dotted module name
    data = None     # a dictionary, {name:<6-list>}:
                    #   0-3 summarize() data: pass5, fail, err, all
                    #   4   bool; whether to show this item
                    #   5   None/False/True; whether the data is recent
    names = None    # a sorted list of names for which show is True
    run = True      # the current state of the run flag
    totals = ()     # a single 4-tuple per summarize()
    __lines = None  # for communication between _set_totals and _set_data
    __raw = ''      # for communication between _call and _set_data


    def __init__(self, stopwords=()):
        """Takes a sequence.
        """
        self.stopwords = stopwords
        self.data = {}
        self.totals = ()
        self.names = []


    # Container emulation
    # ===================

    def __getitem__(self, i):
        """Takes an int index into self.names
        """
        name = self.names[i]
        return [name] + self.data[name]

    def __len__(self):
        """Only count items for which show is True.
        """
        return len(self.names)

    def __iter__(self):
        return self.names.__iter__()
    iterkeys = __iter__


    # Main callable
    # =============

    def refresh(self, base, run=False):
        """Update our information.
        """
        self.base = base
        self.run = run

        self._call()

        self._set_stale()
        self._set_totals()
        self._set_data()
        self._set_names()


    def update(self, name, pass5, fail, err, all):
        """Given data on one testcase, update its info.

        This is called from DetailScreen.

        """
        if name not in self.data:
            raise StandardError("Running detail for module not in " +
                                "summary: %s." % name)
        self._set_stale()
        self.data[name] = [pass5, fail, err, all, True, True]
        self.totals = [pass5, fail, err, all]


    # Helpers
    # =======

    def _call(self):
        """Invoke a child process and return its output.

        We hand on our environment and any sys.path manipulations to the child,
        and we capture stderr as well as stdout so we can handle errors.

        """
        args = ( sys.executable
               , sys.argv[0]
               , '--stopwords=%s' % ','.join(self.stopwords)
               , self.run and '--run' or '--find'
               , '--scripted'
               , '--summary'
               , '--verbose' # always verbose; deal with empties higher up
               , self.base
                )
        logger.debug(' '.join(args))
        environ = os.environ.copy()
        environ['PYTHONPATH'] = ':'.join(sys.path)
        proc = subprocess.Popen( args=args
                               , stdout=subprocess.PIPE
                               , stderr=subprocess.STDOUT
                               , env=environ
                                )
        raw = proc.stdout.read()
        if BANNER not in raw:
            raise RefreshError(raw)
        self.__raw = raw


    def _set_stale(self):
        """Mark currently fresh data as stale.
        """
        for name, datum in self.data.iteritems():
            if datum[5] is True:
                datum[5] = False


    def _set_totals(self):
        """Given self.__raw, set totals and __lines on self.
        """
        lines = self.__raw.splitlines()
        self.totals = tuple(lines[-1].split()[1:])
        del lines[-1]
        self.__lines = lines


    def _set_data(self):
        """Extract and store data from __lines.
        """

        reading_report = False # ignore any output that precedes our report

        for line in self.__lines:

            # Decide if we want this line, and if so, split it on spaces.
            # ===========================================================

            line = line.strip('\n')
            if line == BANNER:
                reading_report = True
                continue
            if (not reading_report) or (not line) or line in (HEADERS, BORDER):
                continue
            tokens = line.split()


            # Convert the row to our record format.
            # =====================================
            # The raw report is already ordered by dotted name, but we need to
            # handle the case where our base is a dotted name.

            name = tokens[0]
            stats = tokens[1:]

            has_tests = int(stats[3]) > 0

            fresh = None
            if has_tests and ('-' not in stats):
                fresh = True

            show = False
            if has_tests:
                show = True
                parts = name.split('.')
                for i in range(len(parts),0,-1):
                    _name = '.'.join(parts[:i])
                    if _name in self.data:
                        self.data[_name][4] = True

            self.data[name] = stats + [show, fresh]

        del self.__lines


    def _set_names(self):
        """Store a sorted list of names for which show is True.
        """
        self.names = sorted([n for n in self.data if self.data[n][4]])
