import os
import subprocess
import sys

from testosterone.cli.utils import BANNER, BORDER, HEADERS


class RefreshError:
    """An error refreshing the summary.
    """

class Summary:
    """Represent the data from an inter-process summarize() call.

    This is designed to be a persistent object. Repeated calls to refresh will
    update the dataset. On partial updates, existing data will be marked as
    stale. There is also a show flag for each record; only items for which this
    are true are included in the name index and __len__ calls.

    """

    data = None     # a dictionary, {name:<6-list>}:
                    #   0-3 summarize() data: pass5, fail, err, all
                    #   4   bool; whether to show this item
                    #   5   None/False/True; whether the data is recent
    names = None    # a sorted list of names for which show is True
    totals = ()     # a single 4-tuple per summarize()
    traceback = ''  # the last traceback to come from _call()
    __lines = None  # for communication between _set_totals and _set_data

    def __init__(self, stopwords=()):
        """Takes a sequence.
        """
        self.stopwords = stopwords
        self.data = {}
        self.totals = ()
        self.names = []


    # Container emulation
    # ===================

    def __getitem__(self, i):
        """Takes an int index into self.names
        """
        name = self.names[i]
        return [name] + self.data[name]

    def __len__(self):
        """Only count items for which show is True.
        """
        return len(self.names)

    def __iter__(self):
        return self.names.__iter__()
    iterkeys = __iter__


    # Main callable
    # =============

    def refresh(self, base, run=False):
        """Update our information.
        """
        raw = self._call(base, run)

        self._set_stale()
        self._set_totals(raw)
        self._set_data()
        self._set_names()


    # Helpers
    # =======

    def _call(self, base, run):
        """Invoke a child process and return its output.

        We hand on our environment and any sys.path manipulations to the child,
        and we capture stderr as well as stdout so we can handle errors.

        """
        args = ( sys.executable
               , sys.argv[0]
               , '--stopwords=%s' % ','.join(self.stopwords)
               , run and '--run' or '--find'
               , '--scripted'
               , '--summary'
               , '--verbose' # always verbose; deal with empties higher up
               , base
                )
        environ = os.environ.copy()
        environ['PYTHONPATH'] = ':'.join(sys.path)
        proc = subprocess.Popen( args=args
                               , stdout=subprocess.PIPE
                               , stderr=subprocess.STDOUT
                               , env=environ
                                )
        raw = proc.stdout.read()
        if BANNER not in raw:
            self.traceback = raw
            raise RefreshError
        return raw


    def _set_stale(self):
        """Mark currently fresh data as stale.
        """
        for name, datum in self.data.iteritems():
            if datum[5] is True:
                datum[5] = False


    def _set_totals(self, raw):
        """Given the raw report, set totals on self; return a list of lines.
        """
        lines = raw.splitlines()
        self.totals = tuple(lines[-1].split()[1:])
        del lines[-1]
        self.__lines = lines


    def _set_data(self):
        """Given a list of lines in a report, extract and store data on self.
        """

        reading_report = False # ignore any output that precedes our report

        for line in self.__lines:

            # Decide if we want this line, and if so, split it on spaces.
            # ===========================================================

            line = line.strip('\n')
            if line == BANNER:
                reading_report = True
                continue
            if (not reading_report) or (not line) or line in (HEADERS, BORDER):
                continue
            tokens = line.split()


            # Convert the row to our record format.
            # =====================================
            # We want to list modules that have non-passing tests, or that
            # have submodules with non-passing tests. Since data is coming
            # to us ordered by dotted module name, we can count on ancestor
            # modules to already be in self.data by the time we get to a
            # submodule with non-passing tests.

            name = tokens[0]
            stats = tokens[1:]

            has_tests = int(stats[3]) > 0

            fresh = None
            if has_tests and ('-' not in stats):
                fresh = True

            show = False
            if has_tests and (stats[0] != '100%'):
                show = True
                parts = name.split('.')[:-1]
                for i in range(len(parts),0,-1):
                    _name = '.'.join(parts[:i])
                    self.data[_name][4] = True

            self.data[name] = stats + [show, fresh]

        del self.__lines


    def _set_names(self):
        """Store a sorted list of names for which show is True.
        """
        self.names = sorted([n for n in self.data if self.data[n][4]])
