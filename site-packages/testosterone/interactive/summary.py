import os
import subprocess
import sys

from testosterone.cli.utils import BANNER, BORDER, HEADERS


class Summary:
    """Represent the data from an inter-process summarize() call.

    This is designed to be a persistent object. Repeated calls to refresh will
    update the dataset. On partial updates, existing data will be marked as
    stale. There is also a show flag for each record; only items for which this
    are true are included in the name index and __len__ calls.

    """

    data = {}   # a dictionary, {name:<6-list>}:
                #   0-3 summarize() data: pass5, fail, err, all
                #   4   bool; whether to show this item
                #   5   None/False/True; whether the data is recent
    totals = () # a single 4-tuple per summarize()
    names = []  # a sorted list of names for which show is True

    def __init__(self, stopwords=()):
        """Takes a sequence.
        """
        self.stopwords = stopwords
        self.data = {}
        self.totals = ()
        self.names = []


    # Mapping emulation
    # =================

    def __getitem__(self, key):
        return self.data[key]

    def __len__(self):
        """Only count items for which show is True.
        """
        return len(self.names)

    def __iter__(self):
        return self.data.__iter__()
    iterkeys = __iter__


    # Main callable
    # =============

    def refresh(self, base, run=False):
        """Update our information.
        """
        raw = self._call(base, run)

        self._set_stale()
        lines = self._set_totals(raw)
        self._set_data(lines)
        self._set_names()


    # Helpers
    # =======

    def _call(self, base, run):
        """Invoke a child process and return its output.
        """
        call = ( sys.executable
               , sys.argv[0]
               , '--stopwords=%s' % ','.join(self.stopwords)
               , run and '--run' or '--find'
               , '--scripted'
               , '--summary'
               , '--verbose' # always verbose; deal with empties higher up
               , base
                )
        proc = subprocess.Popen(call, stdout=subprocess.PIPE, env=os.environ)
        print ' '.join(call)
        return proc.stdout.read()


    def _set_stale(self):
        """Mark currently fresh data as stale.
        """
        for name, datum in self.data.iteritems():
            if datum[5] is True:
                datum[5] = False


    def _set_totals(self, raw):
        """Given the raw report, set totals on self; return a list of lines.
        """
        lines = raw.splitlines()
        self.totals = lines[-1].split()[1:]
        del lines[-1]
        return lines


    def _set_data(self, lines):
        """Given a list of lines in a report, extract and store data on self.
        """

        report_started = False # ignore any output that precedes our report

        for line in lines:

            # Decide if we want this line, and if so, split it on spaces.
            # ===========================================================

            line = line.strip('\n')
            if line == BANNER:
                report_started = True
                continue
            if (not report_started) or (not line) or line in (HEADERS, BORDER):
                continue
            tokens = line.split()


            # Convert the row to our record format.
            # =====================================
            # We want to list modules that have non-passing tests, or that
            # have submodules with non-passing tests. Since data is coming
            # to us ordered by dotted module name, we can count on ancestor
            # modules to already be in self.data by the time we get to a
            # submodule with non-passing tests.

            name = tokens[0]
            stats = tokens[1:]

            has_tests = int(stats[3]) > 0

            fresh = None
            if has_tests and ('-' not in stats):
                fresh = True

            show = False
            if has_tests and (stats[0] != '100%'):
                show = True
                parts = name.split('.')[:-1]
                for i in range(len(parts),0,-1):
                    _name = '.'.join(parts[:i])
                    self.data[_name][4] = True

            self.data[name] = stats + [show, fresh]


    def _set_names(self):
        """Store a sorted list of names for which show is True.
        """
        self.names = sorted([n for n in self.data if self.data[n][4]])
