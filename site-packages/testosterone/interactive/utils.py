import Queue
import threading
import curses


class Spinner:
    """Represent a random work indicator, handled in a separate thread.
    """

    def __init__(self, spin):
        """Takes a callable that actually draws/undraws the spinner.
        """
        self.spin = spin
        self.flag = Queue.Queue(1)

    def offset(self):
        """Show a spinner.
        """
        self.thread = threading.Thread(target=self.spin)
        self.thread.offset()

    def stop(self):
        """Stop the spinner.
        """
        self.flag.put(True)
        self.thread.join()

    def __call__(self, call, *args, **kwargs):
        """Convenient way to run a routine with a spinner.
        """
        self.offset()
        call(*args, **kwargs)
        self.stop()


class DoneScrolling(StandardError):
    """Represents the edge of a scrolling area.
    """


class ScrollArea:
    """Represents a scrollable portion of a screen.
    """

    numrows = 0     # number of viewable rows; 1-indexed
    selected = 0    # index of the currently selected row; 1-indexed
    toprow = 0      # index of the top row relative to the window object

    numitems = 0    # the total number of items in the list; 0-indexed
    start = end = 0 # coordinates in the list of data to display; 0-indexed

    def __init__(self, numrows, numitems, toprow):
        """
        """
        self.numrows = numrows
        self.numitems = numitems
        self.toprow = toprow
        if self.numitems < self.numrows:
            self.end = self.numitems
        else:
            self.end = self.numrows


    def __iter__(self):
        """Return a list of 2-tuples: (index, rownum)

            index -- an index of an item in the current viewport
            rownum -- a rownum relative to the current window object

        """
        j = lambda: self.toprow + i - start
        return [(i, j(i)) for i in range(self.start, self.end)]


    def scroll_one(self, up=False):
        """Scroll the viewport down by one row.
        """

        if up: # scroll up
            if self.selected == 0: # top of viewport
                if self.start == 0: # top of list
                    raise DoneScrolling
                else: # not top of list
                    self.start -= 1
                    self.end -= 1
            else: # not top of viewport
                self.selected -= 1

        else: # scroll down
            if self.start + self.selected == self.numitems: # bottom of list
                raise DoneScrolling
            else: # not bottom of list
                if self.selected == self.numrows: # bottom of viewport
                    self.start += 1
                    self.end += 1
                else: # not bottom of viewport
                    self.selected += 1


    def scroll(self, delta):
        """Support multi-line scrolling.
        """
        up = delta < 0
        delta = abs(delta)
        try:
            for i in range(delta):
                self.scroll_one(up)
        except DoneScrolling:
            self.refuse()


    def refuse(self):
        """Factored out for easier testing.
        """
        curses.beep()


    def page_down(self):
        """
        """
        self.scroll((self.rows*2)-1)
        self.viewrow = 0


    def page_up(self):
        """
        """
        self.scroll(-(self.rows*2)-1)
        self.viewrow = 0
