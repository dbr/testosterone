import Queue
import threading
import curses


class Spinner:
    """Represent a random work indicator, handled in a separate thread.
    """

    def __init__(self, spin):
        """Takes a callable that actually draws/undraws the spinner.
        """
        self.spin = spin
        self.flag = Queue.Queue(1)

    def start(self):
        """Show a spinner.
        """
        self.thread = threading.Thread(target=self.spin)
        self.thread.start()

    def stop(self):
        """Stop the spinner.
        """
        self.flag.put(True)
        self.thread.join()

    def __call__(self, call, *args, **kwargs):
        """Convenient way to run a routine with a spinner.
        """
        self.start()
        call(*args, **kwargs)
        self.stop()


class DoneScrolling(StandardError):
    """Represents the edge of a scrolling area.
    """


class ScrollArea:
    """Represents a scrollable portion of a screen.
    """

    numrows = 0         # number of viewable rows; len semantics
    currow = 0          # index of the currently curitem row; 0-indexed
    toprow = 0          # index of our top row within the window; 0-indexed

    numitems = 0        # the total number of items in the list; len semantics
    curitem = 0         # index of the currently curitem item; 0-indexed
    start = end_ = 0    # coordinates in your list of items; slice semantics

    def __init__(self, numrows, numitems, toprow):
        """
        """
        self.numrows = numrows
        self.numitems = numitems
        self.toprow = toprow
        if self.numitems < self.numrows:
            self.end_ = self.numitems
        else:
            self.end_ = self.numrows

    def __repr__(self):
        return "<ScrollArea %s>" % str(self.stat())
    __str__ = __repr__


    # Container emulation
    # ===================

    def __iter__(self):
        """Return a list of 2-tuples: (index, rownum)

            index -- an index of an item in the current viewport
            rownum -- a rownum relative to the current window object

        """
        return iter(self.__list())

    def __len__(self):
        return len(self.__list())

    def __list(self):
        j = lambda i: self.toprow + i - self.start
        return [(i, j(i)) for i in range(self.start, self.end_)]


    # Basic API
    # =========

    def scroll_one(self, up=False):
        """Scroll the viewport by one row.
        """

        if self.numitems == 0: # short-circuit
            raise DoneScrolling

        if up: # scroll up
            if self.currow == 0: # top of viewport
                if self.start == 0: # top of list
                    raise DoneScrolling
                else: # not top of list
                    self.start -= 1
                    self.end_ -= 1
            else: # not top of viewport
                self.currow -= 1

        else: # scroll down
            if self.curitem + 1 == self.numitems: # bottom of list
                raise DoneScrolling
            else: # not bottom of list
                if self.currow + 1 == self.numrows: # bottom of viewport
                    self.start += 1
                    self.end_ += 1
                else: # not bottom of viewport
                    self.currow += 1

        self.update_curitem()


    def scroll(self, delta):
        """Support multi-line scrolling.
        """
        up = delta < 0
        delta = abs(delta)
        try:
            for i in range(delta):
                self.scroll_one(up)
        except DoneScrolling:
            self._refuse()


    # Extended API
    # ============

    def page_down(self):
        """
        """
        if self.numitems == 0:              # empty page
            self._refuse()
        elif self.numitems <= self.numrows: # partial/single page
            self.currow = self.numitems - 1
            self._refuse()
        elif self.numitems > self.numrows:  # multiple pages
            self.start += self.numrows + 1
            self.end_ += self.numrows + 1
            if self.start > self.numitems:
                self.start = self.numitems - 1
                self.end_ = self.numitems
            elif self.end_ > self.numitems:
                self.end_ = self.numitems
            if self.currow > len(self):
                self.currow = len(self)
                self._refuse()
        self.update_curitem()


    def page_up(self):
        """
        """
        if self.numitems == 0:              # empty page
            self._refuse()
        elif self.numitems <= self.numrows: # partial/single page
            self.currow = 0
            self._refuse()
        elif self.numitems > self.numrows:  # multiple pages
            self.start -= self.numrows + 1
            self.end_ -= self.numrows + 1
            if (self.start < 0) or (self.end_ < 0):
                self.start = 0
                self.end_ = self.numrows
            if self.currow <= 0:
                self.currow = 0
                self._refuse()
        self.update_curitem()


    def home(self):
        """
        """
        if self.numitems == 0:              # empty page
            self._refuse()
        elif self.numitems <= self.numrows: # partial/single page
            if self.currow == 0:
                self._refuse()
            else:
                self.currow = 0
        elif self.numitems > self.numrows:  # multiple pages
            self.start = 0
            self.end_ = self.start + self.numrows
            self.currow = 0
            if self.curitem == 0:
                self._refuse()
        self.update_curitem()


    def end(self):
        """
        """
        if self.numitems == 0:              # empty page
            self._refuse()
        elif self.numitems <= self.numrows: # partial/single page
            if self.currow == self.numitems - 1:
                self._refuse()
            else:
                self.currow = self.numitems - 1
        elif self.numitems > self.numrows:  # multiple pages
            self.currow = self.numrows - 1
            self.end_ = self.numitems
            self.start = self.end_ - self.numrows
            if self.curitem == self.numitems - 1:
                self._refuse()
        self.update_curitem()


    # Helpers
    # =======

    def _refuse(self):
        """Factored out for easier testing.
        """
        self.update_curitem()
        self.refuse()

    def refuse(self):
        """Factored out for easier testing.
        """
        curses.beep()

    def update_curitem(self):
        """
        """
        self.curitem = self.start + self.currow

    def stat(self):
        return ( self.numrows   # 1-indexed
               , self.currow    # 0-indexed
               , self.numitems  # 1-indexed
               , self.start     # 0-indexed
               , self.end_      # 0-indexed
               , self.curitem  # 0-indexed
                )


